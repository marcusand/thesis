\subsection{Applikation}
\label{subs:applikation}

Anforderungen aus \autoref{chap:anforderungen}, welche die eigentliche Applikation 
der Clientsoftware betreffen, sind die Anforderungen \ref{nfa2}, \ref{nfa3} und \ref{nfa8}.\\

\ref{nfa8} stellt die Anforderung der Modularität an das gesamte Softwaresystem. Diese
betrifft also auch die Clientapplikation. Wie in \autoref{sec:backend} bereits erläutert, 
ist für eine große Modularität eine lose Kopplung von Daten- und Präsentationsschicht ein
wichtiger Faktor. Umgekehrt bedeutet dies, dass die Clientsoftware eine in sich geschlossene
eigene Anwendung sein muss. Sie besitzt lediglich die Datenschnittstelle zum CMS. Das leistet im 
Falle der Webtechnologien eine Single-Page Applikation (SPA). Eine SPA wird einmalig von einem 
Server geladen. Laden von weiteren Seiten beim Navigieren durch die Oberfläche 
findet nicht statt \cite{js-definitive}. Um Transaktionen und neue Zustände möglich zu machen,
können jedoch im Hintergrund asynchrone Datenanfragen gemacht werden (AJAX). 
Die SPA gibt so den Nutzer*innen nicht mehr das Gefühl einer
Webseite, sonder einer geschlossenen Anwendung, was im Falle der Kiosksoftware ein gewünschter
Effekt ist und damit in gewisser Weise auch zur Erfüllung der Anforderung \ref{nfa4} beiträgt.\\
Das Laden einer einzigen Seite vom Server bedeutet jedoch nicht, dass keine Navigationsstruktur
mit Vor- und Zurück-Bewegungen implementieren werden kann. Die Navigation findet jedoch alleinig in 
der Clientapplikation statt und ist nicht mit Laden von neuen Seiten verbunden. Es wird lediglich
ein neuer Zustand der Applikation geladen \cite{spa-manifesto}.\\

\ref{nfa2} fordert Offline-Verfügbarkeit. Auch hier trägt das Konzept der SPA zur 
Erbringung der Anforderung bei. Dadurch, dass die Anwendung nur einmal initial geladen werden muss 
und danach vollständig im Client zur Verfügung steht, ist eine Netzwerkverbindung nach dem initialen 
Laden nicht mehr nötig. Das umfasst allerdings nur die eigentliche Applikation und nicht die
AJAX-Anfragen, die auch zu späteren Zeitpunkten erfolgen können. Auch ist bei einem Neuladen
der Applikation immer eine Netzwerkverbindung zwingend nötig. Das Konzept der SPA erfüllt
die Anforderung der Offline-Verfügung also nur zu einem gewissen Teil. Allerdings bildet die Geschlossenheit
einer SPA eine wichtige Voraussetzung um die Applikation auch vollständig offline zur Verfügung
zu stellen. \emph{Vollständig offline} meint hier also, dass beispielsweise auch Daten, die über
einen AJAX-Aufruf aus dem CMS geladen werden, local gecached werden können. Zwar wären Content-Daten bei
Offlinestatus nicht mehr durch das CMS aktualisierbar, aber zumindest die letzte Version solange verfügbar,
bis ein Netzwerkzugriff wieder möglich ist. Um solch einer Anforderung gerecht zu werden, bieten moderne 
Browser die Service-Worker API \cite{service-worker-api}.\\ 
Bei Service-Workern handelt es sich um Proxy-Server, welche sich zwischen der Webanwendung und dem 
Netzwerk befinden. Diese speichern Netzwerkzugriffe in einem lokalen Speicher und können Anfragen auf
diesen verweisen, sollte das Netzwerk bei dem nächsten Zugriff nicht erreichbar sein \cite{service-worker-api}.
Service-Worker werden bei initialem Aufruf heruntergeladen und bleiben auch nach Schließen des Browsers
gespeichert. Das gilt auch für die Daten, welche sie speichern. Diese sind also auch bei Neustart ohne
Netzwerkverbindung noch vorhanden und können angezeigt werden.\\
Eine vollständige Offline-Verfügbarkeit ist also fast erreicht. Einzig Transaktionen, bei welchen Eingaben
und Daten von Nutzer*innen gespeichert werden sollen, können noch nicht offline verfügbar gemacht werden.
Auch hier kommt die Technik der Service-Worker an ihre Grenzen \cite{service-worker-post}.\\
Dennoch gibt es auch hier Lösungen für dieses
Problem. Beispielsweise bietet die JavaScript Datenbank pouchDB \cite{pouchdb} die Möglichkeit POST-Anfragen
und Dateien in einer lokalen Datenbank solange zu speichern, bis eine Netzwerkverbindung wiederhergestellt ist,
um sie dann mit einer Backend-Datenbank zu synchronisieren. Dieser Ansatz wird jedoch im Rahmen dieser Arbeit,
aus Gründen des Umfangs, nicht weiter verfolgt.\\

\ref{nfa8} fordert schließlich die Multilingualität der Oberfläche. Wie in \autoref{sec:backend} 
bereits erläutert, können Datensätze im CMS mehrsprachig angelegt werden. Diese werden der Clientapplikation
in einem Datensatz zur Verfügung gestellt und sind so zu jedem Zeitpunkt verfügbar. 
Nutzer*innen sollen später in der Oberfläche der Clientapplikation die Möglichkeit haben die Sprache
umzustellen. Erfolgt dies, muss keine neue Seite oder neuer Datensatz vom Server angefordert werden, sondern lediglich
die angezeigten Daten durch die entsprechende Sprachversion ausgetauscht werden.\\

\begin{figure}
    \centering
    \includestandalone[width=1\textwidth]{figures/plant/out/ss-app-class-diagram}
    \caption{Komponenten Diagram der \shst{} App}
    \label{fig:ss-app-class-diagram}
\end{figure}

Um dieser beschriebenen Architektur gerecht zu werden, wurde für die Clientapplikation der \shst{} die JavaScript
Bibliotheken React \cite{react} und Redux \cite{redux} zusammen mit dem 
Toolkit Workbox \cite{workbox} verwendet. React bildet dabei
den Rahmen für die SPA-Architektur, Workbox bietet eine Bibliothek welche es erleichtert 
Service-Worker zu implementieren und Redux ist eine Bibliothek welche ein Pattern für die Verwaltung 
von Applikationszuständen implementiert. Redux hilft bei steigender Komplexität von 
Zuständen in Anwendungen -- ist im Rahmen dieser Thesis aber von untergeordneter Bedeutung und wird daher
nicht weiter erläutert.\\

React bietet die Möglichkeit die meisten der zuvor genannten Anforderungen zu erfüllen. 
Das ist neben der Implementierung der SPA-Architektur, auch die Möglichkeit die 
Anwendung zu modularisieren. Denn: Neben der losen Kopplung von CMS und Clientapplikation
ist auch eine Modularität innerhalb der Clientapplikation nötig, um die Anforderung \ref{nfa8}
vollständig zu erfüllen. React erlaubt dies durch sein Komponenten-basiertes System. Einzelne
Interface-Elemente oder auch einzelne Unterseiten können als Komponenten gekapselt werden.
Wie fein diese Kapselung sein soll, kann von den Entwickler*innen entschieden werden. Richtig implementiert,
können Komponenten so wiederverwendet, ausgetauscht oder das System um neue erweitert werden.\\
\autoref{fig:ss-app-class-diagram} zeigt die Komponentenstruktur der Clientapplikation der \shst{}.
Die Abbildung ist vereinfacht und zeigt nur die wichtigsten Komponenten. Die Darstellung orientiert
sich an einem UML-Klassendiagramm, jedoch sind die Klassen in diesem Falle keine Klassen sondern die
Komponenten 
\footnote{React-Komponenten können Klassen sein - müssen aber nicht. Seit React 16.8.0 und
der Einführung der Hook-API \cite{react-hooks} kann sogar gänzlich auf Klassen verzichtet werden und Komponenten 
durchgängig als Funktionen implementiert werden. Das wurde in diesem Falle so umgesetzt.}. 
Rot markierte Komponenten sind Container-Komponenten und haben keine eigene Darstellung, sondern implementieren 
lediglich Geschäftslogik. Blau markierte Komponenten sind Interface-Komponenten, die eine direkte 
Darstellung in der Oberfläche haben. Die eine gelb markierte Komponente ist der Redux-Store. 
Er ist ebenfalls eine besonderer Art der Container-Komponente und beinhaltet den Applikationszustand.\\
Im Zentrum der Abbildung befindet sich die Router-Komponente. Sie leitet zwischen den einzelnen Unterseiten
zu denen die Nutzer*innen navigieren können. Das können entweder Untermenüs oder Module sein, welche
die Funktionalitäten wie die Spenden-Funktion oder die Kontakt-Funktion implementieren. Ein Teilbaum abgehend 
von der Router-Komponente kann dabei immer als Modul gesehen werden. Diese klare Abgrenzung der Module
bietet so die Möglichkeit, die Applikation leicht um neue zu erweitern.
